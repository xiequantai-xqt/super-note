# 关键字

定义：被Java语言赋予了特殊含义，用作专门用途的字符串，比如说public、void等。

特点：全部关键字都是小写字母。

tips：关键字比较多，不需要死记硬背，学到哪里记到哪里即可。

官方地址：https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html

特殊的：const和goto，它们是保留字。

# 识别符

定义：Java中变量、方法、类等要素命名时使用的字符序列，称为标识符。

技巧：凡是自己可以起名字的地方都叫标识符。

命名规则：

1. **组成**：字母（A-Z/a-z）、数字（0-9）、下划线（`_`）、美元符号（`$`）
2. **首字符**：不能是数字（必须以字母、`_`或`$`开头）
3. **区分大小写**：`myVar` 和 `myvar` 不同
4. **禁用关键字**：不能使用`public`、`class`等保留字
5. **无空格**：标识符中不允许出现空格

命名规范：

> 行业规范

1. **类名/接口名**：
   1. **大驼峰式（UpperCamelCase）**：首字母大写，后续单词首字母大写。
   2. 示例：`String`, `ArrayList`, `StudentRecord`。
2. **方法名/变量名**：
   1. **小驼峰式（lowerCamelCase）**：首字母小写，后续单词首字母大写。
   2. 示例：`getName()`, `calculateTotal()`, `studentAge`。
3. **常量名**：
   1. **全大写 + 下划线分隔**：用于`static final`常量。
   2. 示例：`MAX_SIZE`, `PI`, `DEFAULT_TIMEOUT`。
4. **包名**：
   1. **全小写 + 点分隔**，通常使用域名反写。
   2. 示例：`com.example.project`, `org.apache.commons`。
5. **避免使用`$`和`_`开头**：
   1. 虽然合法（如`_name`），但可能被编译器内部使用，易混淆。

示例：

```java
// 定义类（标识符：HelloWorld）
public class HelloWorld {

    // 定义方法（标识符：main）
    public static void main(String[] args) {
        
        // 定义变量（标识符：greeting）
        String greeting = "Hello, World!";
        
        // 调用方法（标识符：System/out/println）
        System.out.println(greeting);
    }
}
```

# 变量

## 变量的类型

在Java中，变量类型可分为两大类：**基本数据类型（Primitive Types）**和**引用数据类型（Reference Types）**。

具体分类如下：

1. **基本数据类型（8种）**
   - **整型（4种）**：
     - `byte`：8位有符号整数（范围：-128 到 127）
     - `short`：16位有符号整数（范围：-32,768 到 32,767）
     - `int`：32位有符号整数（范围：-2³¹ 到 2³¹-1），这个比较常用
     - `long`：64位有符号整数（范围：-2⁶³ 到 2⁶³-1），字面量赋值需要后缀`L`或者`l`（推荐大写）。字面量超过了int类型，必须加上后缀，如果没有超过int类型，可以省略，但是建议保留。

![](https://gitee.com/xiequantai/typora-images/raw/master/IT学习/Java学习/1750646554-Snipaste_2025-06-23_10-42-24.png)

   - **浮点型（2种）**：
     - `float`：32位**单精度**浮点数（需后缀 `f`，如 `3.14f`），尾数可以精确到7位有效数字。声明float时需要提供后缀，后缀是`f`或者`F`。
     - `double`：64位**双精度**浮点数（默认浮点类型），精度是单精度浮点类型的两倍。一般情况下，都会定义double类型，因为精度更高。
     - 说明：
       1. 并不是所有的小数都能精确的用二进制浮点数表示，二进制浮点数不能精确表示0.1、0.01、0.001这样10的负次幂。
       2. 浮点类型float、double的数据不适合在 **不容许舍入误差** 的金融计算领域。如果需要精确数字计算或者保留指定位数的精度，需要使用**BigDecimal**类。

   - **字符型（1种）**：
     - `char`：16位（2字节）Unicode字符（如 `'A'`），总之范围很广，但不能用来表示表情符号

   - **布尔型（1种）**：
     - `boolean`：表示逻辑值（仅 `true` 或 `false`）

2. **引用数据类型（无限种）**
   - **类（Class）**：如 `String`、自定义类（如 `Person`）。
   - **接口（Interface）**：如 `List`、`Runnable`。
   - **数组（Array）**：如 `int[]`、`String[][]`。
   - **枚举（Enum）**：一种特殊的类（Java 5+支持）。
   - **注解（Annotation）**：一种特殊的接口（Java 5+支持）。

> **总结**：  
> - **基本数据类型固定为8种**（数值型6种 + `char` + `boolean`）。  
> - **引用数据类型数量无限**（由开发者定义或Java内置，如类、接口等）。  
>
> 变量的格式： `数据类型 变量名 = 变量值`
>
> **示例代码**：
> ```java
> // 基本数据类型
> int age = 30;
> double price = 19.99;
> char grade = 'A';
> boolean isJavaFun = true;
> 
> // 引用数据类型
> String name = "Alice";          // 类
> int[] numbers = {1, 2, 3};      // 数组
> List<String> list;              // 接口
> ```

## 字符型（char）

### 表现形式

在 Java 中，`char` 类型变量（16 位无符号整数）有以下多种表现形式，这些形式都对应 Unicode 字符：

1. **直接字符字面量**

```java
char c1 = 'A';     // 英文字母
char c2 = '中';    // 中文字符
char c3 = '❤';     // 特殊符号
char c4 = 'あ';    // 日文字符
```

2. **Unicode 转义序列（\\uXXXX）**

```java
char u1 = '\u0041';    // 'A' (U+0041)
char u2 = '\u4e2d';    // '中' (U+4E2D)
char u3 = '\u2764';    // '❤' (U+2764)
char u4 = '\u3042';    // 'あ' (U+3042)
```

3. **整数赋值（十进制/十六进制）**

```java
char d1 = 65;        // 十进制 → 'A'
char h1 = 0x0041;    // 十六进制 → 'A'
char d2 = 20013;     // 十进制 → '中' (20013=0x4E2D)
```

4. **特殊转义字符**

```java
char esc1 = '\n';    // 换行符 (U+000A)
char esc2 = '\t';    // 制表符 (U+0009)
char esc3 = '\\';    // 反斜杠 (U+005C)
char esc4 = '\'';    // 单引号 (U+0027)
```

5. **代理对（Surrogate Pair）表示**

> 用于超出 BMP 的 Unicode 字符（需两个 `char` 组合）
```java
// 😊 (U+1F60A)
char highSurrogate = '\uD83D';  // 高代理项
char lowSurrogate = '\uDE0A';   // 低代理项
String emoji = highSurrogate + "" + lowSurrogate;  // "😊"

// 直接使用字符串
String rocket = "\uD83D\uDE80"; // "🚀" (U+1F680)
```

6. **类型转换**

```java
// int 转 char
int codePoint = 0x4E2D;      // "中" 的码点
char c = (char) codePoint;   // '中'

// char 转 int
int num = 'A';               // 65
```

7. **Character 类方法**

```java
char c = Character.toChars(0x1F60A)[0]; 
// 注意：超出 BMP 的字符会返回 char 数组（需两个元素）

// 码点直接转字符串
String s = Character.toString(128512); // "😀" (U+1F600)
```

关键特性说明：

| **表现形式** | **示例**         | **适用场景**            |
| ------------ | ---------------- | ----------------------- |
| 直接字符     | `'中'`           | 直观表示常见字符        |
| Unicode 转义 | `'\u4e2d'`       | 键盘无法直接输入的字符  |
| 整数赋值     | `char c = 65;`   | 程序生成字符            |
| 特殊转义序列 | `'\n'`           | 控制字符（换行/制表等） |
| 代理对       | `"\uD83D\uDE00"` | 表情符号/罕见字符       |
| 类型转换     | `(char) 0x4E2D`  | 码点与字符转换          |

注意事项：

1. **代理对限制**  
   单个 `char` **不能完整表示**超出基本多语言平面（BMP）的字符（如大部分表情符号），必须使用两个 `char` 或直接操作字符串：
   ```java
   // 错误示例（字符被截断）
   char broken = '😊';  // 编译错误：字符字面量过大
   
   // 正确做法
   String emoji = "😊"; 
   ```

2. **码点直接操作**  
   对于全 Unicode 支持（包括辅助平面），推荐使用码点 API：
   ```java
   String text = "Hello😊";
   int codePoint = text.codePointAt(5);  // 获取 😊 的完整码点 (128522)
   int charCount = text.codePointCount(0, text.length()); // 实际字符数 (6)
   ```

3. **字符与整数互操作性**  
   `char` 可直接参与整数运算：
   ```java
   char c = 'A';
   c++;  // 结果 'B' (66)
   ```

示例代码：混合演示

```java
public class CharDemo {
    public static void main(String[] args) {
        // 多种赋值方式
        char euro = '€';      // 直接字符
        char omega = '\u03A9'; // Unicode 转义
        char heart = 0x2764;  // 十六进制整数
        
        System.out.println(euro);   // €
        System.out.println(omega);  // Ω
        System.out.println(heart);  // ❤

        // 代理对处理表情符号
        String smiley = new String(new char[]{'\uD83D', '\uDE0A'});
        System.out.println(smiley); // 😊

        // 码点操作
        int codePoint = Character.codePointAt(smiley, 0);
        System.out.println("😊 的码点: U+" + Integer.toHexString(codePoint)); // U+1f60a
    }
}
```

> **最佳实践**：当处理国际化文本（尤其是包含表情符号或罕见字符）时，优先使用 `String` 类和 `Character` 的码点方法（如 `codePointAt()`、`codePointCount()`），而非直接操作 `char` 数组。

### 我的疑虑

#### 什么场景下会用到char类型？

1. **你要处理的对象本质就是一个“字符”**：一个字母、一个数字字符、一个符号、一个空格、一个换行符等等。用 `char` 最能清晰表达你的意图。
2. **你需要操作字符串中的单个字符**：遍历字符串、修改特定字符、检查字符属性等。`String` 类底层和 `toCharArray()` 方法都离不开 `char`。
3. **你需要表示键盘按键、游戏角色方向等符号化的东西**：比如用 `'W'`, `'A'`, `'S'`, `'D'` 表示上下左右移动。
4. **你在处理底层文本数据流**：读写文件、网络传输中处理原始字符时。
5. **你需要利用字符编码值做一些简单转换或计算**：并且明确知道自己在做什么。

简单总结就是，**当你脑子里想的是“一个字母”、“一个符号”、“键盘上的一个键”时，就应该考虑用 `char`。** 当你想的是“多少钱”、“多少岁”、“第几个”这种纯粹的数字时，就用 `int` (或其他数字类型)。

## 基本数据类型间的运算规则

### 核心要素

1. 可以做运算的基本数据类型有7种，不包含布尔类型。**`boolean` 类型不能与其他基本数据类型进行算术运算或类型转换**，只能参与逻辑运算（`&&`, `||`, `!`）。
2. 运算规则包含：
   1. 自动类型提升
   2. 强制类型转换
3. 规则

| **规则类型**                   | **说明**                                                     |
| ------------------------------ | ------------------------------------------------------------ |
| **自动类型提升**               | 小容量类型 → 大容量类型（`byte`/`short`/`char` → `int` → `long` → `float` → `double`) |
| **`byte`/`short`/`char` 运算** | 三者任意组合运算，结果均为 `int`                             |
| **强制类型转换**               | `(目标类型) 值`（可能引发精度损失或溢出）                    |
| **字符串拼接**                 | `+` 一侧为 `String` 时，另一侧自动转字符串                   |
| **布尔类型限制**               | `boolean` 不参与算术运算或类型转换                           |

说明：

1. 容量小或者大并非指内存空间的大小，而是指数据表示范围的大小。

示例代码验证：

```java
public class TypeConversion {
    public static void main(String[] args) {
        // 自动类型提升
        byte b = 10;
        double d = b + 3.14;  // 结果提升为 double
        
        // byte/short/char 运算为 int
        char c = 'A';
        short s = 100;
        int r1 = c + s;       // 合法：结果为 int
        
        // 强制转换风险
        int i = 128;
        byte b2 = (byte) i;   // 溢出：b2 = -128
        
        // 字符串拼接
        System.out.println(10 + 20 + "30");   // 输出 "3030"
        System.out.println("10" + 20 + 30);   // 输出 "102030"
    }
}
```

### 基本数据类型特性整理

| 数据类型         | 关键字    | 占用空间 (字节) | 占用空间 (位) | 默认值          | 取值范围/用途说明                                            |
| :--------------- | :-------- | :-------------- | :------------ | :-------------- | :----------------------------------------------------------- |
| **字节型**       | `byte`    | **1 字节**      | 8 位          | `0`             | **-128 到 127** (-2⁷ 到 2⁷ - 1)                              |
| **短整型**       | `short`   | **2 字节**      | 16 位         | `0`             | **-32,768 到 32,767** (-2¹⁵ 到 2¹⁵ - 1)                      |
| **整型**         | `int`     | **4 字节**      | 32 位         | `0`             | **-2,147,483,648 到 2,147,483,647** (-2³¹ 到 2³¹ - 1) ≈ **-21亿 到 21亿** |
| **长整型**       | `long`    | **8 字节**      | 64 位         | `0L`            | **-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807** (-2⁶³ 到 2⁶³ - 1) ≈ 非常大！需加 `L` 后缀（如 `10000000000L`） |
| **单精度浮点型** | `float`   | **4 字节**      | 32 位         | `0.0f`          | **大约 ±3.40282347E+38F** (6-7 位有效小数位)。需加 `F` 或 `f` 后缀（如 `3.14f`） |
| **双精度浮点型** | `double`  | **8 字节**      | 64 位         | `0.0d` 或 `0.0` | **大约 ±1.79769313486231570E+308** (15 位有效小数位)。**Java默认的小数类型**，后缀 `D`/`d` 可选（如 `3.14` 或 `3.14d`） |
| **字符型**       | `char`    | **2 字节**      | 16 位         | `'\u0000'`      | **Unicode 字符**，范围 `'\u0000'` (0) 到 `'\uffff'` (65,535)。可存储中文字符等。 |
| **布尔型**       | `boolean` | **未精确定义**  | 未精确定义    | `false`         | 仅表示 **`true` 或 `false`**。实际 JVM 实现通常用 `int` (4字节) 或 `byte` (1字节) 表示，但依赖于具体虚拟机。 |

**总结规律助记：**

*   **整数：** `byte`(1) < `short`(2) < `int`(4) < `long`(8)
*   **浮点：** `float`(4) < `double`(8) - **默认是`double`**
*   **字符：** `char`(2) - **存Unicode**
*   **布尔：** `boolean` - **大小未定，只有 `true/false`**

### 强制类型转换

Java 的**强制类型转换**（也称为显式类型转换）是指程序员**显式地**告诉编译器，要将一个数据从一种类型转换为另一种类型。这种转换通常发生在编译器无法自动进行安全转换（即隐式转换）的情况下，或者当程序员确信转换是安全的并且符合逻辑时。

**核心特点：**

1.  **显式操作：** 使用强制类型转换运算符 `(目标类型)`。
2.  **潜在风险：** 可能**导致数据丢失**（如精度丢失、值溢出）或**运行时错误**（如 `ClassCastException`）。
3.  **打破编译器的类型安全限制：** 程序员明确承担了转换的责任。

**语法：**

```java
// () 表示强转符

目标类型 变量名 = (目标类型) 表达式或值;
```

**应用场景：**

强制类型转换主要用在两种情况下：

1.  **基本数据类型之间的转换：**
    
    *   **缩小转换：** 将取值范围较大的数据类型（如 `double`, `long`, `int`）转换为取值范围较小的数据类型（如 `float`, `int`, `short`, `byte`, `char`）。这种转换**通常会导致数据丢失**。
    *   **示例：**
        ```java
        double pi = 3.14159;
        int approxPi = (int) pi; // 强制转换为 int， approxPi 的值为 3 (小数部分被截断)
        
        long bigNumber = 3000000000L; // 30亿
        int smallerInt = (int) bigNumber; // 强制转换为 int，可能溢出 (int 最大值约21亿)，smallerInt 的值将是负值或错误值
        
        int num = 97;
        char letter = (char) num; // 强制转换为 char，letter 的值为 'a' (ASCII 97)
        ```
    
2.  **引用类型之间的转换：**
    *   **向上转型：** 将子类引用赋值给父类引用变量。这是**安全的**，并且通常是**隐式**发生的（多态的基础）。虽然不需要强制转换，但也可以显式写出来。
    *   **向下转型：** 将父类引用变量中存储的子类对象引用，**强制转换回**具体的子类引用。这是强制类型转换在引用类型中最主要的应用场景。**存在风险**：如果父类引用变量实际指向的对象不是目标子类（或其子类）的实例，在运行时将抛出 `ClassCastException`。
    *   **示例：**
        ```java
        // 向上转型 (通常是隐式的)
        Animal animal = new Dog(); // Dog 是 Animal 的子类
        
        // 向下转型 (需要显式强制转换)
        if (animal instanceof Dog) { // 安全做法：先进行类型检查
            Dog myDog = (Dog) animal; // 强制转换为 Dog 类型
            myDog.bark(); // 现在可以调用 Dog 特有的方法
        }
        
        // 危险的向下转型 (可能导致 ClassCastException)
        Animal anotherAnimal = new Cat(); // Cat 也是 Animal 的子类
        // Dog badDog = (Dog) anotherAnimal; // 运行时错误: ClassCastException (Cat 不能转成 Dog)
        ```

**关键注意事项和风险：**

1.  **基本数据类型转换：**
    *   **精度丢失：** 浮点数转整数会**直接舍弃小数部分**（不是四舍五入）。例如 `(int) 9.99` 结果是 `9`。
    *   **值溢出：** 如果源值超出了目标类型的范围，结果将是溢出后的值（通常是二进制截断后的值），通常不符合预期且难以调试。例如 `(byte) 128` (byte范围 -128~127) 结果是 `-128`。
    *   **`char`的特殊性：** `char` 是无符号的，与 `short` 虽然都是16位，但直接转换时需要注意符号位问题。

2.  **引用类型转换：**
    *   **`ClassCastException`：** 这是向下转型时最常见的运行时错误。**强烈建议**在向下转型前使用 `instanceof` 运算符检查对象的实际类型。
    *   **类型关系：** 强制转换只能在**具有继承关系**的类/接口之间进行。尝试在毫无关系的类之间转换（如 `String` 转 `Integer`）会导致编译错误。
    *   **数组：** 数组类型也可以强制转换，但同样受继承关系和元素类型兼容性的约束，且容易引发 `ArrayStoreException`。

**总结：**

强制类型转换是 Java 中一个强大的工具，但也是一把双刃剑。使用时必须非常谨慎：

*   **基本类型转换：** 主要用于数值处理，要时刻警惕**精度丢失**和**值溢出**的风险。
*   **引用类型转换：** 主要用于**向下转型**以实现多态行为。**必须**配合 `instanceof` 检查来确保类型安全，避免 `ClassCastException`。
*   **原则：** 尽量避免不必要的强制转换。如果代码中大量出现强制转换，可能需要重新审视设计（如是否过度使用了 `Object` 类型或父类引用）。优先考虑使用泛型、接口或更精确的类型声明来提高类型安全性和代码清晰度。

## 字符串类型的基本使用

> String是引用数据类型，不要弄混了

在Java中，字符串（`String`）是最常用的数据类型之一，用于存储和操作文本数据。以下是字符串类型的基本使用详解：

---

### **1. 创建字符串**
Java提供了两种创建字符串的方式：
- **字面量方式**（推荐）：直接使用双引号`""` 
  
  ```java
  String str1 = "Hello World";  // 存储在字符串常量池中（高效）
  ```
- **构造方法方式**：使用`new`关键字
  
  ```java
  String str2 = new String("Hello World");  // 在堆内存中新建对象
  ```

---

### 2. 字符串不可变性  
字符串一旦创建，其内容**不可修改**（immutable）。所有看似修改的操作实际会返回新字符串对象：
```java
String s = "Java";
s = s + " Programming";  // 创建新对象"Java Programming"，原对象不变
```

---

### **3. 常用操作方法** 
#### (1) 获取信息
- **长度**：`length()`
  ```java
  String str = "Hello";
  int len = str.length();  // len = 5
  ```
- **字符索引**：`charAt(int index)`
  ```java
  char ch = str.charAt(1);  // ch = 'e'（索引从0开始）
  ```

#### (2) 比较字符串
- **内容相等**：`equals(Object obj)`（区分大小写）
  ```java
  boolean isEqual = "Java".equals("java");  // false
  ```
- **忽略大小写**：`equalsIgnoreCase()`
  ```java
  boolean isEqual = "Java".equalsIgnoreCase("java");  // true
  ```
- **字典序比较**：`compareTo(String anotherString)`
  ```java
  int diff = "apple".compareTo("banana");  // 负数（a在b之前）
  ```

#### (3) 子字符串操作
- **截取子串**：`substring(int beginIndex, int endIndex)`
  ```java
  String sub = "HelloWorld".substring(5, 10);  // "World"（含头不含尾）
  ```
- **查找索引**：
  ```java
  int index = "Hello".indexOf('e');      // 1（首次出现位置）
  int lastIndex = "lol".lastIndexOf('l'); // 2（最后出现位置）
  ```

#### (4) 修改操作（返回新字符串）
- **拼接**：`concat()` 或 `+`
  ```java
  String s1 = "Hello".concat(" World");  // "Hello World"
  String s2 = "Java" + "Script";         // "JavaScript"
  ```
- **替换**：`replace(char oldChar, char newChar)`
  ```java
  String s = "apple".replace('p', 't');  // "attle"
  ```
- **大小写转换**：
  ```java
  String upper = "java".toUpperCase();  // "JAVA"
  String lower = "JAVA".toLowerCase();  // "java"
  ```
- **去除空格**：`trim()`
  ```java
  String trimmed = "  Hello  ".trim();  // "Hello"
  ```

#### (5) 类型转换
- **其他类型 → 字符串**：
  
  ```java
  String numStr = String.valueOf(100);     // "100"
  String doubleStr = String.valueOf(3.14); // "3.14"
  ```
- **字符串 → 其他类型**：
  ```java
  int num = Integer.parseInt("123");      // 123
  double d = Double.parseDouble("3.14");  // 3.14
  ```

---

### **4. 字符串拼接性能优化** 
频繁拼接字符串时，避免使用`+`（产生大量临时对象）。推荐：
- **`StringBuilder`**（非线程安全，高效）
  ```java
  StringBuilder sb = new StringBuilder();
  sb.append("Hello");
  sb.append(" ");
  sb.append("World");
  String result = sb.toString();  // "Hello World"
  ```
- **`StringBuffer`**（线程安全，稍慢）

---

### **5. 字符串常量池（String Pool）** 
- JVM为减少重复字符串，维护**字符串常量池**。
- 字面量创建的字符串会存入池中，相同字面量复用对象：
  ```java
  String s1 = "Java";
  String s2 = "Java";
  System.out.println(s1 == s2);  // true（引用相同对象）
  ```
- `new String()`强制创建新对象：
  ```java
  String s3 = new String("Java");
  System.out.println(s1 == s3);  // false（不同对象）
  ```

---

### **6. 格式化字符串** 
使用`String.format()`或`printf`风格格式化：
```java
String name = "Alice";
int age = 25;
String info = String.format("Name: %s, Age: %d", name, age); 
// "Name: Alice, Age: 25"
```

---

### **关键注意事项** 
1. **不可变性**：所有修改操作返回新对象，原字符串不变。
2. **比较内容**：永远用`equals()`而非`==`（`==`比较对象地址）。
3. **拼接优化**：循环内拼接用`StringBuilder`。
4. **空字符串检查**：
   
   ```java
   if (str != null && !str.isEmpty()) { ... }
   ```

掌握这些基础操作后，可高效处理Java中的文本数据！

# 算术运算符

