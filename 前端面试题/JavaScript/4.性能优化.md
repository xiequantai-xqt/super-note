# 一、JavaScript脚本延迟加载的方式有哪些？

1. defer属性：当在`<script>`标签中添加`defer`属性后，浏览器会继续解析 HTML 文档，而不会阻塞文档的解析。脚本会在文档解析完成后，按照在文档中出现的顺序依次执行。
2. async属性：`async`属性也能让脚本异步加载。和`defer`不同的是，`async`加载的脚本一旦加载完成，就会立即执行。主要用于那些不依赖于页面其他内容的独立脚本，例如一些统计脚本或者广告脚本。
3. 动态创建脚本元素：通过 JavaScript 动态创建`<script>`元素，并将其添加到文档中。这种方式可以更加灵活地控制脚本的加载时机，例如在某些用户交互事件发生后或者满足一定条件后再加载脚本。
4. 使用模块加载器，实现模块的异步加载。

# 二、哪些情况会导致内存泄漏？

内存泄漏指的是程序分配的内存没有被适时释放，导致可用内存逐渐减少，可能最终影响程序性能甚至导致程序崩溃。以下是几种常见的导致内存泄漏的情况：

1. **全局变量**：未及时解除对全局变量的引用，使得本应被释放的对象一直被引用，无法被垃圾回收。
2. **闭包**：当闭包中引用了外部函数的变量，且这个外部变量所占用的内存空间很大或者生命周期很长时，若闭包长时间存在，则可能导致这部分内存无法被释放。
3. **事件监听器**：未移除的事件监听器，特别是当监听器绑定到DOM元素上，而该DOM元素又未被适当清理时，会导致相关对象和它们所引用的内存无法被回收。
4. **定时器（setTimeout, setInterval）**：如果定时器启动后没有被正确清除，它们会持续引用相关的回调函数及其作用域链上的变量，阻止这些对象被回收。
5. **未清理的DOM元素引用**：即使DOM元素从页面中移除，但如果JavaScript代码中仍有对该元素的引用，该元素及其相关子元素所占用的内存就不会被释放。
6. **缓存未限制**：无限制地缓存数据或对象，如果缓存策略不当，可能会无限积累，占用越来越多的内存。
7. **单例和静态变量**：单例对象和静态变量的生命周期与应用程序相同，如果它们不慎持有其他对象的引用，可能导致这些对象无法被回收。
8. **循环引用**：特别是在使用一些语言特性如JavaScript的原型链或复合对象时，对象之间形成循环引用，而这些对象又不再被外部所引用，也可能导致内存泄漏。
9. **第三方库或框架使用不当**：不正确地使用第三方库或框架也可能导致内存泄漏，尤其是在它们管理资源或生命周期方面。

# 三、什么是防抖和节流？有什么区别？

- 防抖是指在事件被触发 n 秒后再执行回调函数，如果在这 n 秒内事件又被触发，则重新计时。就像是等电梯，有人按了电梯按钮（触发事件），电梯会等待一段时间（n 秒）才关门出发，如果在这等待期间又有人按按钮，那么等待时间就会重新计算。
- 节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在这个单位时间内触发多次事件，只有一次能生效。可以想象成水龙头放水，不管你怎么频繁地拧水龙头（触发事件），水（回调函数执行）都是按照一定的速率流出来。

区别：

1. 执行次数不同
   - **防抖**：在事件持续触发的过程中，回调函数可能一直不会执行，只有当事件触发停止后，并且在规定的等待时间内没有再次触发，回调函数才会执行一次。
   - **节流**：在规定的单位时间内，无论事件触发多少次，回调函数最多只执行一次。在持续触发事件的过程中，会按照固定的时间间隔执行回调函数。
2. 应用场景侧重点不同
   - **防抖**：更侧重于在事件停止触发后的一次性操作，主要用于一些 “输入完成后” 的操作，如用户输入完成后的搜索、用户停止拖拽后的操作等。
   - **节流**：侧重于在事件持续触发过程中，按照一定的频率来执行操作，适用于需要持续监听事件，但又不能让事件处理函数过于频繁执行的场景，如滚动加载、鼠标跟踪等。