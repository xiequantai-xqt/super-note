# 一、setTimeout、Promise、Async/Await 的区别？

1. **`setTimeout`**：
   - `setTimeout` 是一个全局函数，用于在指定的毫秒数后执行一个回调函数。它不保证精确的延迟时间，因为其他任务可能会插入到执行队列中。
   - 它是回调函数的一个基础形式，但不支持链式操作，也不直接与Promise结合。

2. **`Promise`**：
   - `Promise` 是一个对象，用于表示一个异步操作的最终完成（成功或失败）及其结果。它有三个状态：pending（等待中）、fulfilled（已完成）和rejected（已拒绝）。
   - 通过`.then()`和`.catch()`方法，可以链式处理异步操作的结果，支持错误处理。
   - Promise 提供了更优雅的方式来组织异步代码，避免了回调地狱。

3. **`Async/Await`**：
   - `async/await` 是ES2017引入的语法糖，用于简化Promise的使用。`async`关键字定义了一个异步函数，而`await`关键字用于等待Promise的结果。
   - 通过`await`，异步操作可以在代码中看起来像是同步的，提高了代码的可读性。
   - `async/await` 结合了Promise的优点，同时提供了更接近同步代码的编写体验。

总的来说，`setTimeout` 是一个简单的异步延迟执行工具，`Promise` 用于管理和组合异步操作，而`async/await` 是Promise的高级语法，提供了更易读和易于管理的异步代码编写方式。

# 二、对Promise的理解？

Promise是JavaScript中用于处理异步操作的一种编程模式，它提供了一种更加结构化的方式来管理异步操作的结果，避免了传统的回调地狱，使得异步代码更加清晰和易于维护。

1. **基本概念**：
   - Promise代表一个异步操作的最终完成（或失败）及其结果的容器。它有三种状态：pending（进行中）、fulfilled（已成功，又称resolved）和rejected（已失败）。
   - 一旦Promise从pending变为fulfilled或rejected，其状态就不能再改变，这就是所谓的“状态不可逆”。
2. **创建Promise**：
   - 使用`new Promise((resolve, reject) => {})`构造函数创建Promise实例，其中`resolve`和`reject`是两个函数，分别用于标记操作成功或失败，并传递结果值。
3. **链式调用**：
   - 通过`.then()`方法处理成功的结果，通过`.catch()`处理失败的情况。`.then()`和`.catch()`返回新的Promise，允许进一步链式调用。
   - 另外，`.finally()`方法无论Promise成功还是失败都会执行，用于清理操作或执行最终的逻辑。
4. **错误处理**：
   - 错误可以通过`.catch()`捕获，它会在Promise链中任何地方抛出的错误处被捕获，包括前面的`.then()`或`.catch()`中的错误。
5. **并发与组合**：
   - 使用`Promise.all()`可以并行执行多个Promise，并在所有Promise都成功完成后解析结果数组。
   - `Promise.race()`则是只要任意一个Promise完成（不论是成功还是失败）就立即返回结果或错误。
6. **静态方法**：
   - `Promise.resolve(value)`用于直接创建一个已解决的Promise。
   - `Promise.reject(reason)`用于直接创建一个已拒绝的Promise。
7. **异步编程基础**：
   - Promise是现代JavaScript异步编程的基础，特别是与`async/await`语法一起使用时，可以编写看起来像同步代码的异步逻辑，极大地提高了代码的可读性和可维护性。

# 三、Promise.all和Promise.race的区别的使用场景？

Promise.all：

- **用途**：当需要等待多个异步操作都完成时使用。它接收一个Promise数组作为参数，只有当所有这些Promise都变为fulfilled状态时，`Promise.all`返回的Promise才会变为fulfilled状态，结果是一个包含所有Promise结果的数组。
- 适用场景：
  - 页面加载需要多个独立数据源的数据全部准备好后才能渲染。
  - 批量上传文件，只有当所有文件上传成功后才通知用户。
  - 并行处理多个任务，且所有任务完成是后续逻辑的前提。

Promise.race：

- **用途**：当只需要关注多个Promise中的最快完成的一个（无论是fulfilled还是rejected状态）时使用。它同样接收一个Promise数组作为参数，一旦数组中的任何一个Promise改变状态（变为fulfilled或rejected），`Promise.race`返回的Promise就会立即以相同的状态结束。
- 适用场景：
  - 设置超时机制，比如某个操作不能超过一定时间，可以用一个定时器的Promise与实际操作的Promise进行race，先完成的决定后续逻辑。
  - 在多个数据源中选择响应最快的，比如从多个CDN下载资源，选取最先返回的资源使用。
  - 竞争条件检查，比如在并发操作中，只关心谁先完成，不在乎其他。

总结：

- `Promise.all`适用于需要确保所有操作都成功完成的场景，强调的是集体协作完成。
- `Promise.race`则适用于竞争场景，关注的是速度和优先级，哪个Promise先有结果就采用哪个结果。

# 四、对async/await 的理解？

1. **async 函数**：
   - `async` 关键字用于定义一个异步函数。这样的函数总是返回一个Promise，即使函数中没有明确的返回值，也会隐式返回一个解析为`undefined`的Promise。
   - 在`async`函数内部，可以使用`await`关键字。
2. **await 表达式**：
   - `await` 用于等待一个Promise完成。它后面通常跟一个Promise，这个Promise的结果将被返回给表达式。如果Promise解析，`await`表达式的值就是Promise的结果；如果Promise被拒绝，`await`表达式将抛出一个错误。
   - `await` 只能在`async`函数内部使用。
3. **错误处理**：
   - 在`async`函数内部，`await`后面的Promise如果被拒绝，会抛出一个异常，可以使用`try...catch`来捕获这个异常。
4. **返回值**：
   - `async`函数返回一个Promise，这个Promise的解析值是`await`表达式的结果，如果`await`后面没有Promise，那么这个Promise的解析值就是`undefined`。
5. **链式调用**：
   - `async`函数可以像Promise一样链式调用，因为它们都返回Promise，所以可以使用`.then()`和`.catch()`来处理异步操作的结果。
6. **同步代码的外观**：
   - `async/await` 让异步代码看起来更像同步代码，提高了代码的可读性和可维护性。
7. **并发与顺序**：
   - 即使在`async`函数内部，`await`后面的Promise也可以并行执行，但是`await`后面的代码会等待Promise解析后再继续执行，确保了执行顺序。

# 五、async/await的优势？

1. **代码可读性**：`async/await`使得异步代码看起来更像同步代码，减少了回调函数的嵌套，从而降低了阅读和理解代码的难度。代码结构更加线性，易于跟踪和维护。
2. **简洁的错误处理**：通过使用标准的`try...catch`语句，`async/await`使得错误处理更加集中和直观，避免了Promise链中繁琐的`.catch()`调用，使得代码更加整洁。
3. **更自然的控制流**：在`async`函数中，可以使用`await`暂停函数执行，等待Promise解析，这使得编写复杂的异步逻辑变得更加自然，例如条件语句、循环等，就像处理同步代码一样。
4. **中间值处理简化**：与Promise相比，使用`await`可以直接获取Promise的结果，无需通过`.then()`传递中间值，使得处理异步操作的结果更加直接和简便。
5. **调试友好**：在`async`函数中，可以像调试同步代码那样设置断点，因为`await`会暂停函数执行直到Promise解决，这使得在调试异步代码时更容易追踪和理解程序的执行流程。
6. **保留执行堆栈**：当异步操作中发生错误时，`async/await`能够提供更完整的堆栈跟踪，帮助开发者更快定位问题，这是因为它们保留了函数调用的上下文。
7. **原生支持和广泛兼容**：现代浏览器和Node.js环境都原生支持`async/await`，这意味着不需要额外的编译步骤，同时也享受到了语言层面的优化和支持。

# 六、说说你对事件循环的理解？

1. 首先，JavaScript 引擎会执行同步代码，将同步代码按顺序执行完。在执行同步代码的过程中，可能会产生异步任务，这些异步任务会根据其类型（宏任务或微任务）分别被添加到任务队列或微任务队列中。
2. 当同步代码执行完毕后，引擎会检查微任务队列。如果微任务队列中有任务，就会按照先进先出的顺序逐个执行微任务，直到微任务队列为空。
3. 微任务队列清空后，引擎会检查任务队列。如果任务队列中有任务，就会取出一个任务并执行，执行完这个任务后，又会检查微任务队列，看是否有新的微任务产生（因为执行宏任务的过程中可能会产生微任务），重复上述步骤。
4. 这个过程会不断循环，直到任务队列和微任务队列都为空，这时 JavaScript 引擎就会等待新的任务进入队列。