# 第一组

## 一、GET和POST请求的区别

1. **用途**
   - **GET**: 请求资源数据（只读操作，如查询）。
   - **POST**: 发送数据到服务器（写入操作，如提交表单）。
2. **参数传递**
   - **GET**: 参数通过 URL，明文可见，会被缓存或记录历史。
   - **POST**: 参数在请求体中，不显示在 URL，更安全。
3. **数据长度限制**
   - **GET**: URL 长度有限，受浏览器和服务器限制。
   - **POST**: 理论无长度限制，但受服务器配置约束。
4. **幂等性**
   - **GET**: 幂等，每次请求结果一致。
   - **POST**: 非幂等，多次请求可能导致多次操作。
5. **缓存机制**
   - **GET**: 可被浏览器缓存。
   - **POST**: 一般不缓存。
6. **安全性**
   - **GET**: 参数可见，敏感数据易泄露。
   - **POST**: 参数隐藏，安全性较高，但仍需 HTTPS 加密。

## 二、POST和PUT请求的区别

1. **语义**
   - **POST**: 创建新资源，可导致服务器端资源重复创建。
   - **PUT**: 更新资源或创建新资源（如果不存在），是幂等操作，多次请求结果一致。
2. **幂等性**
   - **POST**: 非幂等，多次请求可能导致重复操作。
   - **PUT**: 幂等，对同一资源多次请求效果相同。
3. **数据处理方式**
   - **POST**: 通常不指明目标资源位置，由服务器决定数据存储位置。
   - **PUT**: 客户端需提供完整资源及明确的目标 URL。
4. **替换资源**
   - **POST**: 添加新资源，不替代现有资源。
   - **PUT**: 替换现有资源（若完整数据提供），部分更新可用 PATCH 实现。
5. **返回状态码**
   - **POST**: 通常返回 `201 Created`，若无新建资源则返回 `200 OK` 或 `204 No Content`。
   - **PUT**: 成功更新资源返回 `200 OK` 或 `204 No Content`，创建新资源返回 `201 Created`。

## 三、常见的HTTP请求头和响应头

常见的 HTTP 请求头：

1. **Accept**: 指定客户端可处理的内容类型（如 `text/html` 或 `application/json`）。
2. **Accept-Language**: 指定客户端可接受的语言。
3. **Authorization**: 包含认证信息，用于身份验证。
4. **Content-Type**: 表明请求中数据的媒体类型（POST/PUT 时使用）。
5. **Cookie**: 客户端发送的存储信息，用于会话管理。
6. **Host**: 指定目标主机名，用于区分多站点。
7. **Referer**: 指明请求来源页面，常用于分析和日志。
8. **User-Agent**: 描述发起请求的客户端信息。

常见的 HTTP 响应头：

1. **Access-Control-Allow-Origin**: 用于配置跨域资源共享 (CORS)。
2. **Cache-Control**: 定义缓存策略（如最大存活时间）。
3. **Content-Type**: 指明响应内容的媒体类型。
4. **Content-Length**: 响应内容的字节大小。
5. **Location**: 重定向时指向的新 URL 地址。
6. **Set-Cookie**: 服务端用于设置客户端的 Cookie。
7. **Server**: 包含服务端软件的基本信息。
8. **Last-Modified**: 指示资源的最后修改时间。
9. **ETag**: 资源的唯一标识，用于缓存验证。
10. **Expires**: 指明缓存到期时间。

## 四、HTTP状态码304是多好还是少好

“304状态码表示‘未修改’（Not Modified），它是HTTP缓存机制的一部分，允许客户端使用本地缓存的资源，而不是重新向服务器请求资源。具体来说，当客户端请求资源时，会带上上次请求时资源的‘Last-Modified’时间戳或‘If-None-Match’标头。如果服务器检测到资源自上次请求以来没有发生变化，就会返回304状态码，告诉客户端使用缓存资源。

关于304状态码是多好还是少好，实际上，304出现得越多，通常表明缓存机制越有效。因为这意味着客户端已经能够利用缓存来减少重复的网络请求，从而减少了带宽消耗和服务器的压力，有助于提升页面加载速度和用户体验。所以，在理想情况下，304状态码出现频繁是一个好现象。

然而，如果304状态码很少出现，可能意味着缓存策略没有被充分利用，或者客户端和服务器之间的缓存头信息配置不正确。在这种情况下，可能会导致不必要的资源重新下载，增加延迟和带宽消耗，从而影响性能。

因此，304状态码多好，但前提是缓存策略设置合理，确保不造成额外的请求或不必要的负载。”

关键点：

1. **304的定义**：解释304状态码的含义和作用。
2. **304出现的场景**：说明304状态码多的情况下，客户端有效使用缓存，减少网络请求。
3. **304少的影响**：分析304状态码出现过少的原因，并提到可能是缓存策略不合理导致性能问题。
4. **总结**：304状态码多是好事，前提是缓存策略得当。

## 五、常见的HTTP请求方法

1. **GET**
   - 用于请求指定资源。数据通过URL传递（查询参数），一般用于获取数据，不会改变服务器的状态。
   - 示例：请求某个页面或API数据。
2. **POST**
   - 用于向服务器发送数据，常用于表单提交或上传文件。POST请求的数据存储在请求体中，通常会导致服务器状态的变化。
   - 示例：提交用户注册信息。
3. **PUT**
   - 用于更新指定资源。请求体中包含更新后的数据，常用于修改资源的现有状态，通常会替换整个资源。
   - 示例：更新用户资料。
4. **DELETE**
   - 用于删除指定资源。
   - 示例：删除指定的用户或文章。
5. **PATCH**
   - 用于部分更新资源，通常只更新资源的某些字段，而不是替换整个资源。与PUT的区别在于，PUT通常是全面更新，而PATCH是局部更新。
   - 示例：更新用户的邮箱地址。
6. **HEAD**
   - 与GET类似，但服务器响应中只返回头部信息，不返回实际数据体。通常用于获取资源的元信息（例如文件的大小、类型等）。
   - 示例：检查一个文件是否存在。
7. **OPTIONS**
   - 用于查询服务器支持的HTTP方法或进行跨域请求的预检请求（CORS）。返回的是允许的HTTP方法列表。
   - 示例：浏览器发起的CORS预检请求。
8. **TRACE**
   - 用于跟踪请求-响应链，回显服务器收到的请求。通常用于诊断和调试。
   - 示例：查看请求在服务器中如何被处理。

**tips**：

你可以通过举例子和应用场景来加深面试官对你理解的信任。例如，GET常用于浏览器访问网页，POST常用于提交表单数据，PUT常用于更新资源等等。

根据实际情况和面试官的提问深度，你可以进一步讲解状态码、幂等性、缓存等相关概念，展现你的全面理解。

## 六、OPTIONS请求方法及使用场景

1. **OPTIONS请求方法简介**

- **定义**：`OPTIONS`方法用于查询服务器支持哪些HTTP请求方法，或是请求资源时允许的操作。它通常用于跨域资源共享（CORS）场景中，用于查看服务器是否允许跨域请求。
- **返回**：服务器会返回一个响应，其中包含允许的HTTP方法和相关的其他信息。响应头一般会包含`Allow`字段，列出服务器支持的HTTP方法。

2. **使用场景**

- CORS（跨域资源共享）
  - 当浏览器发起跨域请求时，浏览器首先会发送一个`OPTIONS`请求（预检请求）来确认目标服务器是否允许当前域名的跨域请求。如果服务器允许跨域，它会在响应头中返回相关的CORS头部（如`Access-Control-Allow-Origin`、`Access-Control-Allow-Methods`等）。
  - **例子**：假设你在`https://domainA.com`站点上做前端开发，想通过`https://domainB.com/api`接口获取数据，浏览器会首先发送一个`OPTIONS`请求到`https://domainB.com`，询问是否允许`domainA.com`发起跨域请求。若服务器响应了合适的CORS头部，浏览器才会继续发起实际的请求。
- 服务器查询支持的方法
  - `OPTIONS`方法也可以用来查询一个特定的URL支持哪些HTTP方法，尤其是在你不知道某个URL支持哪些方法时，发送`OPTIONS`请求可以帮助你了解。
  - **例子**：某个API接口支持多种HTTP方法（如`GET`、`POST`、`DELETE`等），你可以发送`OPTIONS`请求来了解哪些方法是允许的。

3. **返回的响应**

- 当服务器响应

  ```
  OPTIONS
  ```

  请求时，响应头中可能会包含以下信息：

  - `Allow`：列出该资源支持的HTTP方法（如`GET, POST, PUT, DELETE`等）。
  - `Access-Control-Allow-Methods`：列出跨域请求时允许的HTTP方法。
  - `Access-Control-Allow-Origin`：指定哪些域名可以访问该资源。
  - `Access-Control-Allow-Headers`：列出哪些HTTP头部可以用于实际请求。

4. **总结**

- `OPTIONS`请求方法主要用于了解目标资源支持的HTTP方法，尤其在CORS场景中，它是浏览器向服务器发起的“预检请求”。
- 在CORS中，`OPTIONS`请求的响应帮助浏览器决定是否继续发送实际的请求，确保跨域操作的安全性。

你可以根据这个思路来回答，展示你对`OPTIONS`方法的理解，并举出常见的应用场景，尤其是CORS中的重要作用。这样不仅回答了问题，还能展现你对Web安全机制的掌握。

## 七、HTTP1.0和HTTP1.1之间有哪些区别

**1. 持久连接**

- **HTTP 1.0**：每次请求都需要重新建立连接。
- **HTTP 1.1**：默认使用持久连接（Keep-Alive），多个请求复用同一连接。

**2. 管道化**

- **HTTP 1.0**：不支持管道化，请求顺序执行。
- **HTTP 1.1**：支持管道化，可以并发发送多个请求。

**3. 缓存控制**

- **HTTP 1.0**：使用 `Expires` 头部进行缓存控制。
- **HTTP 1.1**：引入 `Cache-Control`，提供更灵活的缓存策略。

**4. 虚拟主机**

- **HTTP 1.0**：每个 IP 地址绑定一个网站。
- **HTTP 1.1**：支持虚拟主机，通过 `Host` 头部支持多个网站共享同一 IP。

**5. 错误代码**

- **HTTP 1.0**：状态码较少。
- **HTTP 1.1**：引入更多状态码，如 `416`、`417` 等。

## 八、HTTP1.1和HTTP2.0的区别

1. **传输方式**

   - **HTTP 1.1**：基于文本协议，所有请求和响应以纯文本格式发送。

   - **HTTP 2.0**：使用二进制协议，数据以二进制帧进行传输，效率更高。

2. **多路复用（Multiplexing）**

   - **HTTP 1.1**：同一连接上只能处理一个请求/响应，多个请求需要建立多个连接，导致性能下降（尤其是在高延迟的网络环境中）。

   - **HTTP 2.0**：支持多路复用，即在同一连接上可以并行处理多个请求/响应，显著提高了性能。

3. **头部压缩**

   - **HTTP 1.1**：头部信息每次请求都重复发送，效率低。

   - **HTTP 2.0**：引入了头部压缩（HPACK），减少了头部数据的重复传输，提高了性能。

4. **服务器推送（Server Push）**

   - **HTTP 1.1**：没有服务器推送功能，客户端需要发出所有请求。

   - **HTTP 2.0**：支持服务器推送，服务器可以主动向客户端推送资源，减少请求次数。

5. **请求优先级**

   - **HTTP 1.1**：请求按顺序处理，无法指定请求的优先级。

   - **HTTP 2.0**：支持请求优先级，可以根据重要性和依赖关系调整请求的处理顺序。

6. **连接管理**

   - **HTTP 1.1**：每个请求需要建立新的连接，使用 **Keep-Alive** 维持连接，但仍然有限制。

   - **HTTP 2.0**：只有一个连接就可以处理所有请求，减少了连接的开销。

## 九、HTTP与HTTPS协议的区别

HTTP和HTTPS的主要区别在于安全性。HTTP是一个明文协议，传输的数据没有加密，因此容易被窃听和篡改。而HTTPS是在HTTP的基础上添加了SSL/TLS加密层，保障数据在传输过程中不会被窃听或篡改，确保了数据的机密性、完整性和身份验证。HTTPS会使用443端口，而HTTP使用80端口。在实际应用中，HTTPS广泛应用于需要安全通信的场景，如在线支付、登录等，因为它提供了强大的加密和认证机制。

## 十、GET方法URL长度限制的原因

GET请求的URL长度限制主要是由浏览器和Web服务器的实现来决定的，通常在2,000字符左右。这个限制的原因有几个方面。首先，URL过长可能会影响性能，因为它需要更多的带宽和处理能力。其次，过长的URL可能会带来安全隐患，因为它可能暴露过多的信息。最后，HTTP协议本身对URL长度没有硬性限制，但实际使用中大多数浏览器和服务器对URL的长度都有限制。对于需要传输大量数据的场景，推荐使用POST请求，因为POST请求不受URL长度的限制，可以通过请求体传递大量数据。

## 十一、当浏览器输入Google.com并且按下回车之后发生了什么

1. **解析URL**：浏览器会检查输入的URL，默认使用`http://`协议（或`https://`如果它支持）。
2. **DNS解析**：浏览器会查找`google.com`对应的IP地址，通常通过DNS服务器完成这个过程。
3. **建立TCP连接**：获得IP地址后，浏览器与Google的服务器通过TCP三次握手建立连接。如果是HTTPS，浏览器还会进行SSL/TLS握手，确保通信是加密的。
4. **发送HTTP请求**：浏览器向服务器发送HTTP请求，要求获取页面内容。
5. **服务器响应**：Google的服务器返回HTTP响应，其中包含HTML、CSS、JavaScript和其他资源。
6. **渲染页面**：浏览器解析HTML，构建DOM树和CSSOM树，生成渲染树并显示网页。
7. **加载资源**：浏览器会继续请求其他资源，如图片、视频等，并在加载完毕后渲染完整页面。
8. **关闭连接**：页面加载完毕后，浏览器会关闭与服务器的连接。

## 十二、keep-alive的理解

Keep-Alive是HTTP/1.1中的一项连接持久化特性，允许客户端和服务器在同一个TCP连接上发送多个HTTP请求和响应，从而避免为每个请求都重新建立TCP连接。其工作原理是在HTTP请求和响应头中通过`Connection: keep-alive`指示保持连接。在多个请求复用同一连接的情况下，能够大大减少连接建立和关闭的开销，提高性能，特别是在加载多个资源的网页中表现尤为明显。

不过，需要注意的是，Keep-Alive会占用服务器的连接资源，长时间保持连接可能会影响服务器的处理能力。此外，随着HTTP/2的出现，它通过多路复用技术进一步优化了连接的使用，使得Keep-Alive的优势在HTTP/2中有所减弱。

总的来说，Keep-Alive适用于需要频繁请求服务器资源的场景，能够显著提升网络传输效率。

## 十三、页面有多张图片，HTTP是怎样的加载表现

当页面有多张图片时，浏览器会为每张图片发起独立的HTTP请求。每当浏览器遇到`<img>`标签时，它会解析图片的URL并发起GET请求，下载相应的图片资源。在HTTP/1.x协议中，浏览器对同一域名的并发请求数量有一定限制（通常为6-8个），因此如果页面中的图片超过了这个数量，浏览器会按顺序处理这些请求，而不是同时加载所有图片，这会导致一定的加载延迟。

在性能方面，图片数量过多会影响页面的加载速度，尤其是在网络条件不佳时，图片请求的排队和等待会增加页面的加载时间。为了优化这种情况，可以采用HTTP/2协议，它支持多路复用，允许在一个TCP连接上并发请求多个资源；还可以通过CSS Sprite将多张图片合并为一张大图片，减少请求数量。此外，图片懒加载和图片压缩也能有效提升页面加载速度。

## 十四、HTTP2的头部压缩算法是怎样的

HTTP/2的头部压缩是通过HPACK算法来实现的，HPACK通过两种机制来减少头部数据的冗余：静态表和动态表。

1. **静态表**：HPACK定义了一些常见的头部字段（如`User-Agent`、`Content-Type`等），为它们分配了固定的索引。当这些常见头部出现时，客户端和服务器可以使用该索引来代替传输整个头部内容。
2. **动态表**：HPACK允许在会话过程中创建和维护一个动态表，存储会话期间发送的头部。当相同的头部字段再次出现时，客户端和服务器可以使用该头部在动态表中的索引来传输头部，避免重复传输相同的头部数据。
3. **增量编码**：HPACK使用增量编码的方式，只传输变化的部分。例如，当请求中的某个头部发生了变化，只会传输变化的部分，而不是每次都传输完整的头部。

通过这些方式，HPACK能大大减少HTTP请求和响应中的头部大小，减少带宽消耗和延迟，提高页面加载速度和性能。

## 十五、HTTP请求报文是什么样的

HTTP请求报文是客户端向服务器发送的请求数据，它由以下几部分组成：

1. **请求行**：包含请求方法（如GET、POST）、请求的资源URI、HTTP协议版本。 例如：`GET /index.html HTTP/1.1`。

2. **请求头**：包含多种键值对，用于描述请求的其他信息，如客户端的类型（`User-Agent`）、接受的数据类型（`Accept`）、连接管理（`Connection`）等。 例如：

```makefile
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html,application/xhtml+xml
```

3. **请求体**：可选部分，通常用于POST请求，包含要发送的数据，如表单数据、JSON数据等。

请求报文的结构是：请求行 + 请求头 + 空行 + 请求体。具体内容取决于请求方法和应用场景，GET请求通常没有请求体，而POST请求则有。

## 十六、HTTP响应报文是什么样的

HTTP响应报文是服务器返回给客户端的数据，它包含了以下几部分：

1. **响应行**：包含HTTP版本、状态码和状态消息。例如，`HTTP/1.1 200 OK`表示请求成功，服务器返回了一个`200`状态。
2. **响应头**：包含一些附加信息，如`Content-Type`（指定返回内容的类型）、`Content-Length`（返回内容的长度）、`Server`（服务器信息）等。
3. **空行**：响应头和响应体之间的空行，标识头部结束。
4. **响应体**：包含实际的响应数据，如HTML、JSON或其他类型的内容。响应体对于大部分请求是必需的，但某些响应（如`204 No Content`）没有响应体。

完整的HTTP响应报文结构如下：

```makefile
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 137
Server: Apache/2.4.41 (Unix)
Date: Mon, 15 Jan 2025 09:00:00 GMT
Cache-Control: no-cache

<html>
  <head><title>Example</title></head>
  <body><h1>Welcome to Example.com</h1></body>
</html>

```

通过这样的结构，客户端能够理解服务器返回的结果，并渲染相应的页面或处理数据。

## 十七、HTTP协议的优点和缺点

HTTP协议的优点包括：

1. **简单易用**，容易实现和调试。
2. **跨平台**，支持各种操作系统和设备。
3. **无连接**，减少了服务器的负担，提高了扩展性。
4. **支持多种媒体类型**，能够传输文本、图片、视频等各种内容。
5. **灵活性强**，支持不同的请求方法和自定义头部。
6. **支持缓存机制**，提升了性能。

然而，HTTP也有一些缺点：

1. **无状态性**，每次请求都是独立的，需要额外机制来保持会话状态。
2. **性能瓶颈**，特别是在HTTP/1.x中，建立TCP连接的开销较大。
3. **明文传输**，容易受到中间人攻击，导致数据泄露。
4. **带宽浪费**，请求头部信息的冗余传输占用带宽。
5. **没有流量控制和拥塞控制**，可能导致性能下降。

为了弥补这些缺点，HTTP/2和HTTPS提供了更好的性能和安全性，HTTP/2通过多路复用减少了连接开销，而HTTPS通过加密提高了数据传输的安全性。

## 十八、说一下HTTP3.0

HTTP/3是HTTP协议的最新版本，它基于QUIC协议，使用UDP代替TCP，以提高网络连接和传输的效率。HTTP/3的一个重要特点是它减少了连接建立的延迟，并支持0-RTT连接建立，这在高延迟环境下特别有用。

与HTTP/2相比，HTTP/3具有更强的多路复用能力，避免了TCP连接中的头部阻塞问题。同时，HTTP/3强制使用TLS 1.3加密，提高了安全性。它还能够在网络条件不佳、频繁切换网络时保持连接，提升了移动设备上的用户体验。

然而，HTTP/3也存在一些挑战，比如部署复杂度较高，需要支持QUIC的服务器和CDN，且UDP在某些网络环境下可能遇到限制。总体来说，HTTP/3为Web性能和安全性带来了显著提升，尤其在高延迟和不稳定的网络环境下。

## 十九、HTTP协议的性能怎么样

HTTP协议的性能主要受版本和网络环境的影响。在HTTP/1.x中，性能瓶颈主要来自于TCP连接的建立和头部阻塞问题。每个请求都需要建立新的TCP连接，或者即便是Keep-Alive连接也会受制于TCP的慢启动和拥塞控制，这使得多个小请求变得非常低效。

HTTP/2通过多路复用技术，允许在同一连接上并行发送多个请求和响应，避免了头部阻塞问题。同时，HTTP/2使用了二进制协议和HPACK头部压缩，进一步减少了延迟和带宽占用。

HTTP/3在此基础上使用QUIC协议，通过UDP代替TCP，减少了连接建立的时间，并支持0-RTT连接建立，进一步降低了延迟，特别适合高延迟或频繁切换网络的场景。

总体来看，HTTP/3在性能上是目前最优的，特别是在高延迟、移动网络和复杂网络环境下，提供了显著的性能提升。

## 二十、URL有哪些组成部分

URL由多个部分组成，通常包括以下几个部分：

1. **Scheme**（协议）——例如`http`、`https`，指定访问资源使用的协议；
2. **Host**（主机）——如`www.example.com`，指定资源所在的服务器地址；
3. **Port**（端口号）——如`80`、`443`，用于指定与服务器建立连接的端口，通常省略时使用协议默认端口；
4. **Path**（路径）——如`/images/photo.jpg`，表示资源在服务器上的位置；
5. **Query**（查询字符串）——如`?id=123&category=books`，用于向服务器传递参数，动态获取资源；
6. **Fragment**（片段标识符）——如`#section2`，用于定位页面中的特定位置。
