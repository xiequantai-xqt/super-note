# 数据类型

## 一、JavaScript有哪些数据类型，它们的区别？

JavaScript的数据类型可以分为两大类，基本数据类型和引用数据类型。

基本数据类型：

1. **Number**: 表示数字，可以是整数或浮点数，包括Infinity、-Infinity和NaN（非数字）。
2. **String**: 表示文本，由零个或多个字符组成，使用单引号(' ')或双引号(" ")包围。
3. **Boolean**: 只有两个值：`true` 和 `false`，用于逻辑判断。
4. **Null**: 表示一个刻意的空值，只有一个值`null`，用来表示一个变量被赋值为空对象指针。
5. **Undefined**: 表示变量已被声明但未被赋值，只有一个值`undefined`。
6. **BigInt**: 用于存储超过常规`Number`类型安全整数范围的大整数。
7. **Symbol**: ES6引入的新类型，表示独一无二的值，常用于对象的唯一属性键。

引用数据类型：

1. **Object**: 包括普通对象、数组(Array)、函数(Function)等，存储在堆内存中，变量实际存储的是指向这些数据的引用（地址）。

数据类型的区别：

1. **存储方式**：基本数据类型直接存储值，存储在栈内存中；引用数据类型在栈中存储的是引用地址，数据本身存储在堆内存中。
2. **复制行为**：基本数据类型的变量复制给另一个变量时，会创建一个新的值，两者互不影响。而引用数据类型复制时，复制的是引用，因此改变其中一个变量的值可能会影响到另一个。
3. **值的比较**：基本数据类型使用`==`或`===`比较时，直接比较值或者类型是否相等。引用数据类型使用`==`比较可能会发生类型转换，使用`===`则要求类型和值都相等。
4. **内存占用**：基本数据类型占用的内存相对固定且较小。引用数据类型根据数据的实际大小动态分配内存，可能占用更多内存空间。

## 二、数据类型检测的方式有哪些？

1. typeof：返回一个表示变量数据类型的字符串。对于基本类型值（不包括`null`和`undefined`）和函数非常准确。
2. instanceof：用于检测构造函数的`prototype`属性是否出现在某个实例对象的原型链上，以此判断该对象是否是这个构造函数的实例。

```javascript
variable instanceof Constructor // 语法
[] instanceof Array  // true
```

3. constructor：每个对象都有一个内置的constructor属性，指向创建该对象的构造函数。但这个属性可以被修改，所以不是完全可靠。

```javascript
variable.constructor === Constructor // 语法
(new Date()).constructor === Date  // true
```

4. Object.prototype.toString.call()：是最准确的数据类型检测方法之一，可以区分所有基本类型和引用类型，包括null和undefined。

```javascript
Object.prototype.toString.call(variable)  // 语法
Object.prototype.toString.call([])  // "[object Array]"
```

## 三、判断数组的方式有哪些？

1. **Array.isArray()**
   - **用途**：ES5引入的标准方法，专门用来判断一个值是否为数组。
   - **语法**：`Array.isArray(variable)`
   - **例子**：`Array.isArray([])` 返回 `true`。
2. **instanceof**
   - **用途**：检查一个对象是否是某个构造函数的实例。
   - **语法**：`variable instanceof Array`
   - **例子**：`[] instanceof Array` 返回 `true`。
3. **对象的constructor属性**
   - **用途**：检查对象的`constructor`属性是否指向`Array`构造函数。
   - **语法**：`variable.constructor === Array`
   - **注意**：此方法可能因`constructor`被重写而不准确。
4. **检查__proto__**
   - **用途**：检查对象的`__proto__`属性是否等于`Array.prototype`。
   - **语法**：`variable.__proto__ === Array.prototype`
   - **注意**：`__proto__`属性在某些旧的或不兼容的环境中可能不存在。
5. **toString()方法**
   - **用途**：调用对象的`toString()`方法，返回"[object Array]"表示是数组。
   - **语法**：`Object.prototype.toString.call(variable) === "[object Array]"`
   - **优点**：这种方法比较通用，适用于各种情况，包括跨环境。

在实际开发中，`Array.isArray()`通常是首选方法，因为它是最安全和最标准的。其他方法在某些特定情况下可能不可靠，尤其是当涉及到对象的原型链被篡改时。

## 四、null和undefined区别？

1. **类型差异**：
   - `undefined`是一种基本数据类型，其类型本身即为`undefined`。
   - `null`也是一种基本数据类型，但有趣的是，使用`typeof`操作符检查`null`时，会返回`"object"`，这是一个历史遗留问题，实际上它并不是对象类型。
2. **含义差异**：
   - `undefined`通常表示变量已声明但尚未被赋值，或者声明前使用变量，再或者函数没有返回值的情况。
   - `null`则常常被用作一个故意设置的空值，表示某个变量意在指向一个对象，但现在没有指向任何对象。
3. **逻辑比较**：
   - 在宽松相等(`==`)比较中，`null`和`undefined`被认为是相等的，因为它们都代表“无值”。
   - 使用严格相等(`===`)时，它们不相等，因为它们是两种不同的数据类型。
4. **转换行为**：
   - 在转换为布尔值时，两者都会被转换为`false`。
   - 在转换为数值时，`undefined`转换为`NaN`，而`null`转换为`0`。

## 五、map和Object的区别？

1. 键的类型：Map的键类型可以是任意类型，Object的键类型只能是string或者Symbol。
2. 遍历顺序：遍历Map对象时，会按照插入的顺序返回键值对。Object的遍历顺序在不同的JS引擎下可能是不同的。
3. 获取属性值：Map通过get方法获取指定键的值，Object通过 点语法 或者 方括号 的语法访问属性值。
4. 使用场景：当需要频繁操作数据，同时键的类型比较复杂时，可以选择Map。

## 六、map和weakMap的区别？

1. 键的类型：Map的键类型可以是任意类型，WeakMap的键类型只能是对象。
2. 内存管理：Map中的键值对只要没有被显式删除，就会一直存在于内存中，会阻止垃圾回收器回收作为键的对象，即使在代码的其他地方不再使用这个对象。当一个对象作为键被添加到  WeakMap  后，如果在  WeakMap  之外没有对这个对象的其他引用，垃圾回收器可以在适当的时候回收这个对象及其相关的键值对。这有助于防止内存泄漏，特别是在处理对象缓存等场景时非常有用。
3. 可枚举性：Map对象是可枚举的，可以通过entries()获取迭代器。WeakMap是不可枚举的，因为  WeakMap  的键是弱引用，其内容随时会因为垃圾回收而改变，所以不适合提供遍历机制。

## 七、其他值到字符串的转换规则？

1. Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"，
2. Boolean 类型，true 转换为 "true"，false 转换为 "false"。
3. Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。
4. Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。
5. 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。

## 八、其他值到数字值的转换规则？

1. Undefined 类型的值转换为 NaN。
2. Null 类型的值转换为 0。
3. Boolean 类型的值，true 转换为 1，false 转换为 0。
4. String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。
5. Symbol 类型的值不能转换为数字，会报错。
6. 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。

## 九、其他值到布尔类型的值的转换规则？

以下这些是假值：

1. undefined
2. null
3. false
4. +0、-0 
5. NaN 
6. ""

假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。

## 十、substring和substr函数的区别是什么？

从兼容性方面来说，substring 是 JavaScript 标准方法，在各种新旧浏览器中兼容性良好，自 ECMAScript 1 起就被支持。substr 虽被广泛支持，但已被标记为非标准方法，在未来的 JavaScript 版本或严格环境中可能被废弃或修改，不过目前主流浏览器如 Chrome、Firefox、Safari 等仍支持它。

在实际应用场景中，substring 更适用于依据明确的索引位置范围提取子字符串，比如从文件路径中提取文件名。而 substr 侧重于从指定起始位置提取固定长度的字符串，例如从固定格式的短信内容里提取特定长度的验证码等。

# 变量声明

## 一、let、const、var的区别？

1. 作用域
   - var: 在函数作用域或全局作用域中声明变量。在函数外部声明的 var 变量会成为全局变量。在函数内部，var 会被提升至函数作用域的顶部。
   - let 和 const: 引入了块级作用域的概念。这意味着它们声明的变量仅在其所在的代码块（如 if 语句、for 循环或其他大括号包裹的任意代码块）内有效。let 和 const 不会被提升至块级作用域的顶部。
2. 变量重新赋值
   - var和let: 允许变量被重新赋值。
   - const: 声明的是常量，一旦赋值就不能再次更改，如果试图重新赋值给 const 变量会导致错误。如果是引用数据类型，虽然不能重新赋值整个变量，但可以修改其内部属性或元素。
3. 变量提升
   - var: 存在变量提升现象，可以在声明之前访问变量，此时值为 undefined。
   - let 和 const: 没有变量提升到作用域顶部的现象，如果在声明前访问，会引发 ReferenceError。
4. 暂时性死区
   - let 和 const: 在它们声明之前的区域被称为暂时性死区，在这个区域内访问这些变量会报错。

## 二、const对象的属性可以修改吗？

在JS中，当使用const关键字声明并且初始化一个对象，这个变量实际上保存的是指向那个对象的一个引用地址。这个地址是固定的，引用地址指向的内存是可以修改的。

# 运算符

## 一、typeof null 的结果是什么，为什么？

`typeof null` 的结果是 `"object"`。原因是JavaScript最初实现的时候，所有值都被设计为可以存储在一个32位的单元中，其中包含一个类型标签来指示值的类型。`null` 值的二进制表示是全0，这在当时的类型标记系统中恰好与对象类型的标记相匹配。因此，当对 `null` 应用 `typeof` 操作符时，它会错误地被识别为 `"object"`。尽管这一行为被认为是一个错误，由于修正它会导致大量依赖现有行为的代码出现问题，因此这一特征就被保留了下来。

## 二、intanceof 操作符的实现原理?

`instanceof` 操作符用于判断一个对象是否是另一个对象的实例，或者是否在其原型链上存在另一个对象的构造函数。它的实现原理基于JavaScript的原型链机制。

## 三、typeof 与 instanceof 区别

1. 作用不同：typeof 主要用于检测基本数据类型，而 instanceof 用于检查对象是否属于特定类或构造函数的实例。
2. 适用范围不同：typeof 对于原始值和函数非常有效，但对于所有对象（包括数组和 null）都返回 "object"。instanceof 则主要用于对象，特别是当需要区分不同类型的对象时。
3. 实现原理不同：typeof 是基于值的类型直接判断，而 instanceof 是通过原型链来判断一个对象是否是某个构造函数的实例。

# 浮点数

## 一、为什么0.1+0.2 ! == 0.3，如何让其相等？

这个现象出现是因为浮点数的表示和计算存在精度问题。

1. **使用容差比较**：定义一个很小的正数作为容差，然后比较两个浮点数之差的绝对值是否小于这个容差。

```javascript
   function isEqualWithPrecision(a, b, precision = 1e-15) {
     return Math.abs(a - b) < precision;
   }
   console.log(isEqualWithPrecision(0.1 + 0.2, 0.3)); // 输出：true
```

2. **使用toFixed方法**：将浮点数转换为字符串，指定小数点后的位数，然后再转回数字进行比较。但这种方法也有其局限性，特别是当涉及较大或较小的数值时，可能会有信息丢失。

```javascript
   console.log((0.1 + 0.2).toFixed(10) === '0.3'); // 注意：这种方法在特定情况下可能不准确
```

# 深拷贝&浅拷贝

## 一、object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别？

两者都是浅拷贝的方式。

区别：

- Object.assign() 方法可以将所有可枚举的属性的值从一个或多个源对象复制到目标对象，返回值是目标对象。
- 扩展运算符与 Object.assign() 类似，也是用来创建一个新的实例，但它通常用于函数调用或字面量表达式中。

# ES6+特性

## 一、ES6引入了哪些特性？

ES6（ECMAScript 2015）是JavaScript语言的一个重要版本，它在ES5的基础上增加了很多新特性，极大地丰富了JavaScript的语法和功能。以下是ES6引入的一些主要特性：

1. **块级作用域**：`let` 和 `const` 关键字用于声明变量，与`var`不同的是，它们具有块级作用域，并且`const`声明的变量值不可改变。
2. **箭头函数**：提供了一种更简洁的函数表达式语法，同时改变了函数内部`this`的绑定规则，箭头函数内的`this`会继承外部作用域的`this`值。
3. **解构赋值**：可以从数组或对象中提取数据并赋值给变量，简化了数据处理的过程。
4. **模块化**：ES6引入了`import`和`export`关键字，支持按需加载代码，提高了代码的复用性和组织性。
5. **类**：类是基于原型的面向对象编程的一种语法糖，使创建对象更加方便，支持继承、静态方法等特性。
6. **Promise**：虽然Promise的概念在ES6之前就已经存在，但是ES6将其纳入标准，使得异步操作更加规范和易于管理。
7. **Symbol**：是一种新的原始数据类型，它的值是唯一的，可以作为对象属性的标识符，确保不会与其他属性名冲突。
8. **Set 和 Map 数据结构**：
   - `Set` 是一个不包含重复值的集合。
   - `Map` 是一个简单键值对的数据结构，其中每个键都是唯一的。
9. **迭代器和生成器**：
   - 迭代器是一种访问集合元素的方式，而生成器是一种可以返回迭代器的特殊函数。
10. **Proxy 和 Reflect**：
    - `Proxy` 对象用于定义自定义行为（如属性查找、赋值、枚举、函数调用等），`Reflect` 是一组用于操作对象的静态方法。

## 二、在 JavaScript 的 ES6 类语法中，解释构造函数（constructor）的作用。如何在类中定义方法和属性？请举例说明。

它是类中的一种特殊方法，在使用 `new` 关键字创建类的实例时被自动调用。主要用于初始化实例对象的属性，可以接受参数，并将这些参数赋值给实例的属性，从而确定实例的初始状态。

定义属性：可以直接在类的内部使用 `this` 关键字来定义属性。

```javascript
class Person {
  constructor(name, age) {
    // 定义实例属性
    this.name = name;
    this.age = age;
  }
}
```

定义方法：在类中定义方法时，直接在类的内部声明函数即可。

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  // 定义实例方法
  sayHello() {
    console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
  }
}

let person = new Person('John', 25);
person.sayHello(); 
```

# 遍历

## 一、for...in和for...of的区别？

1. 语法含义：
   1. **for...in**：主要用于遍历对象的可枚举属性（包括继承的可枚举属性）。例如，对于一个对象，`for...in`循环会遍历对象的键名。
   2. **for...of**：用于遍历可迭代对象（iterable）的值，如数组、字符串、`Map`、`Set`等。它是在 ES6 中引入的，提供了一种简洁的方式来遍历这些数据结构中的元素。
2. 不适用场景：
   1. for...in 用于数组，虽然`for...in`可以用于数组，但它遍历的是数组的索引（作为对象的属性），而不是数组元素本身。这可能会导致一些意外的结果，特别是如果数组的原型被修改或者在遍历过程中数组的长度发生变化。
   2. for...of 用于普通对象，`for...of`不能直接用于普通对象，因为普通对象不是可迭代对象（它们没有默认的迭代器）。如果要使用`for...of`遍历对象，需要先定义对象的迭代器（通过`Symbol.iterator`方法）。

## 二、如何使用for...of遍历对象？

虽然`for...of`循环不直接支持遍历普通对象的属性，但有一些策略可以实现类似的功能。以下是几种方法：

1. **使用`Object.keys()`或`Object.entries()`**：

   - `Object.keys(obj)`返回一个包含对象所有可枚举属性名称的数组。
   - `Object.entries(obj)`返回一个数组，其中每个元素是一个包含属性名和对应值的数组。

   可以使用`for...of`遍历这两个方法返回的数组：

```javascript
   const obj = { a: 1, b: 2, c: 3 };

   for (const key of Object.keys(obj)) {
     console.log(key, obj[key]);
   }

   // 或者

   for (const [key, value] of Object.entries(obj)) {
     console.log(key, value);
   }
```

2. **使用`Symbol.iterator`**：如果想要在对象上实现迭代器，可以给对象添加`Symbol.iterator`属性，指向一个返回迭代器的函数。然后，`for...of`可以遍历这个迭代器。

```javascript
   const obj = {
     [Symbol.iterator]: function* () {
       yield 'a';
       yield 'b';
       yield 'c';
     },
   };

   for (const key of obj) {
     console.log(key);
   }
```

3. 使用`Object.getOwnPropertyNames()`：这个方法返回一个包含对象所有（包括不可枚举的）属性名称的数组，可以配合`for...of`遍历。

```javascript
   const obj = { a: 1, b: 2, c: 3, [Symbol.unscopables]: true };

   for (const key of Object.getOwnPropertyNames(obj)) {
     console.log(key);
   }
```

4. 使用`Reflect.ownKeys()`：返回一个包含对象所有属性（包括不可枚举的和Symbol属性）的数组。

```javascript
   const obj = { a: 1, [Symbol('secret')]: 2 };

   for (const key of Reflect.ownKeys(obj)) {
     console.log(key);
   }
```