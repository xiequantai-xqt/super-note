# 一、响应式原理与性能优化类

## 1.vue的基本原理？

1. **数据绑定和响应式系统**：Vue的核心是数据驱动，通过`Object.defineProperty`实现数据的双向绑定，通过`Observer`类监控数据变化，确保视图与数据的实时同步。
2. **虚拟DOM**：Vue使用虚拟DOM来提高性能，当数据变化时，通过计算最小的DOM变更来更新实际DOM，降低不必要的DOM操作。
3. **组件化开发**：Vue强调组件化，每个组件封装独立的功能和样式，可复用性强，构建复杂的UI结构。
4. **模板语法**：Vue提供简洁的模板语法，使用`{{ }}`插值表达式和指令（如`v-if`, `v-for`, `v-bind`, `v-on`）来声明式地处理逻辑。
5. **计算属性和侦听器**：计算属性用于根据其他数据计算衍生值，自动缓存结果；侦听器则监听数据变化并触发相应操作。
6. **生命周期钩子**：Vue组件有多个生命周期钩子函数，如`created`, `mounted`, `updated`, `destroyed`，在组件的不同阶段执行特定任务。
7. **插件扩展**：Vue生态系统丰富，如Vue Router用于路由管理，Vuex用于状态管理，增强应用功能。
8. **性能优化**：Vue提供多种性能优化策略，如条件渲染、列表渲染的key属性、组件懒加载和缓存等。

## 2.双向数据绑定的原理？

Vue.js 实现双向数据绑定的原理主要是基于以下两个核心机制：

1. **数据劫持（Data Hijacking）**：
   - **Vue 2.x 版本**：
     - 主要通过 `Object.defineProperty` 方法来实现。Vue 会在初始化时遍历数据对象的属性，并使用 `Object.defineProperty` 为每个属性添加 getter 和 setter。
     - getter 用于在访问属性时获取值，setter 则在属性值被修改时触发。当数据发生变化时，setter 会通知 Vue，Vue 随后会更新与该数据相关的 DOM 元素。
   - **Vue 3.x 版本**：
     - 采用了更现代的 Proxy API 来替代 `Object.defineProperty`。Proxy 可以拦截对象上几乎所有的操作，包括读取、设置属性值，以及迭代等，提供了更全面的数据劫持能力。

2. **发布-订阅模式（Publisher-Subscriber Pattern）/ 响应式系统**：
   - Vue 内部维护了一个依赖收集器，当数据被访问时，Vue 会记录下这个数据的依赖关系，即哪些视图依赖于这个数据。
   - 当数据发生变化时，Vue 会通过发布-订阅模式，通知所有依赖于该数据的视图进行更新。这一过程涉及到 Watcher（观察者）的概念，每个 Watcher 会监听数据的变化，并在数据变化时执行相应的更新逻辑。

**双向数据绑定的典型应用场景**

双向数据绑定的典型应用场景是表单输入控件，如 `v-model` 指令。它实际上是一个语法糖，结合了数据绑定和事件监听。当表单输入值发生变化时，Vue 会通过上述机制自动更新数据模型；反之，当数据模型发生变化时，Vue 也会自动更新表单的显示值，实现了数据与视图之间的双向同步更新。

## 3.使用 Object.defineProperty() 来进行数据劫持有什么缺点？

使用 `Object.defineProperty()` 进行数据劫持的缺点：

1. **无法监听属性的动态添加和删除**：
   - `Object.defineProperty()` 只能对已经存在的属性进行劫持。对于动态添加或删除的属性，需要额外的代码来跟踪和处理，否则这些新属性不会是响应式的。

2. **数组操作的局限性**：
   - 对于数组，虽然 Vue 通过特殊的方法（如 `push`, `pop`, `splice` 等）覆盖了数组的原型，以便在这些方法内部更新依赖，但这并不能完全覆盖所有数组操作，比如通过索引直接修改数组元素或使用 `length` 属性。

3. **性能开销**：
   - 遍历和定义每个对象属性会产生一定的性能成本，尤其是当对象有大量属性或者属性层级较深时，初始化和更新成本较高。

4. **不支持深层观测**：
   - 如果对象包含嵌套的对象或数组，需要递归地定义每个子属性，否则嵌套的数据不会响应式。

5. **不完全的数组变化检测**：
   - 尽管 Vue 尝试检测某些数组变化，但并不能捕捉到所有情况，例如通过索引直接修改数组元素，Vue 可能无法感知到这种变化。

6. **不兼容性**：
   - `Object.defineProperty()` 是 ES5 的方法，虽然现代浏览器普遍支持，但在旧版浏览器中可能不工作，需要额外的 polyfill。

7. **限制了某些 JavaScript 特性**：
   - 例如，`Object.seal()`, `Object.freeze()` 或 `Object.preventExtensions()` 这些方法会影响到响应式系统的正常工作，因为它们阻止了对象的进一步扩展。

**解决方案：**

- **Vue 3.x 中通过引入 ES6 的 Proxy 对象解决了这些问题**：
  - Proxy 可以更全面地拦截对象的读写操作，包括动态属性的添加和删除，以及数组的变异操作，提供了更好的响应式能力和性能。
  - 不过，Proxy 在一些旧的浏览器环境中可能存在兼容性问题。

## 4.defineProperty和proxy的区别？

1. **静态 vs 动态**：`defineProperty`是静态的，一旦定义，属性的元数据基本固定；而`Proxy`是动态的，可以改变其行为，提供更灵活的拦截和控制。
2. **拦截范围**：`defineProperty`只能单独定义一个属性，而`Proxy`可以拦截对象的所有操作，包括访问、修改、删除属性等。
3. **元数据控制**：`defineProperty`可以精确控制单个属性的元数据，如可写性、可枚举性、可配置性；`Proxy`则提供了更全面的控制，可以定义更复杂的拦截规则。
4. **使用场景**：`defineProperty`适合于对特定属性进行特殊处理或保护，而`Proxy`适用于需要广泛拦截和控制对象操作的场景，如数据验证、缓存等。
5. **兼容性**：`defineProperty`在ES5中就已经可用，浏览器支持较好；`Proxy`是ES6的新特性，部分老版本浏览器可能不支持，需要考虑兼容性问题。
6. **性能**：`Proxy`通常比`defineProperty`开销更大，因为它涉及到更多的运行时操作和拦截。

## 5.Vue3.0 为什么要用 proxy？

1. **全方位拦截**：`Proxy`可以拦截对象上的所有操作，包括读取（get）、设置（set）、删除（deleteProperty）、枚举（enumerate）、迭代（ownKeys）、赋值（has）、方法调用（apply、construct）等，这比`Object.defineProperty`只能拦截个别属性的get和set操作要强大得多。
2. **动态监听**：在Vue2.x中，`Object.defineProperty`只能在对象创建时定义响应式属性，一旦对象创建，就无法动态添加新的响应式属性。而`Proxy`可以监听对象的动态添加和删除属性，使得Vue3能更好地适应动态数据结构。
3. **深度监听**：在Vue2.x中，为了实现深度响应式，需要递归地对对象的每个层级进行定义，这在处理嵌套数据结构时性能较低。而`Proxy`可以监听整个对象，无需手动递归，提升了性能。
4. **更少的运行时开销**：虽然`Proxy`在创建时可能有更高的开销，但一旦创建，它在后续操作中的性能通常优于`Object.defineProperty`，特别是在处理大量数据时。
5. **更好的类型安全**：与`Object.defineProperty`相比，`Proxy`更易于与TypeScript等强类型语言配合，提供更好的类型检查和智能感知。
6. **更好的开发体验**：`Proxy`使得Vue3的响应式系统更加直观和简洁，开发者可以编写更接近自然语言的代码，提高代码的可读性和可维护性。
7. **兼容未来技术**：`Proxy`是ES6的特性，符合现代JavaScript的发展趋势，使用它能更好地利用现代浏览器的特性，为未来的功能扩展和优化打下基础。

# 二、状态管理与响应式原理类

## 1.Vuex 的原理？

1. **状态集中管理**：Vuex通过一个单一的store（仓库）保存应用的所有状态。这个store就是一个JavaScript对象，包含应用的state（状态）、mutations（变更函数）、actions（动作）、getters（计算属性）和modules（模块）。
2. **响应式数据**：Vuex中的state是响应式的，当state发生改变时，所有依赖于此state的组件都会自动更新。这得益于Vue的响应式系统，确保了视图与状态的一致性。
3. **严格的状态变更**：为了保证状态变更的可追踪和可预测，Vuex强制所有的状态变更都必须通过mutations来完成。Mutations是同步的，且每个mutation都有一个字符串类型的事件类型（type）和一个回调函数（handler），这个函数接收state作为第一个参数，第二个参数可选，通常用于传递导致状态变更的载荷（payload）。
4. **异步操作与Actions**：由于mutations必须是同步的，对于需要处理异步操作（如API调用）的情况，Vuex引入了actions。Actions可以包含任意异步操作，并通过commit调用来触发mutations，从而间接更新state。
5. **模块化**：对于复杂的应用，Vuex支持模块划分，每个模块拥有自己的state、mutations、actions和getters，这有助于组织和管理大型应用的状态。
6. **Getters**：类似于Vue的computed属性，getters用于从store的状态派生出一些状态，可以认为是store的计算属性。Getters可以接受其他getters作为参数，也可以接受state作为参数，使得状态的获取更加灵活和高效。

## 2.Vuex中action和mutation的区别？

**Mutation:**

1. **目的**：
   - Mutation 是 Vuex 中更改状态（state）的唯一途径，它直接处理 state 的修改，确保这些变更可追踪且容易调试。

2. **性质**：
   - Mutation 必须是同步函数，这意味着它们在执行期间不会进行异步操作，如 API 调用或 `setTimeout`，这有助于保持状态变更的简洁性和可预测性。

3. **调用方式**：
   - Mutation 通过 `store.commit` 方法触发，传入一个 mutation 的名称（字符串）和可选的载荷（payload）。

4. **记录和调试**：
   - Vuex DevTools 可以记录每次 mutation 的执行，帮助开发者追踪状态变化的历史，便于调试和理解应用的行为。

**Action:**

1. **目的**：
   - Action 负责处理复杂的逻辑，特别是那些涉及异步操作的逻辑，比如调用后端 API。它们不直接修改 state，而是通过触发 mutation 来间接更新 state。

2. **性质**：
   - Action 可以是异步函数，这使得它们非常适合处理网络请求、长时间运行的任务等场景。

3. **调用方式**：
   - Action 通过 `store.dispatch` 方法触发，同样接收一个 action 的名称和可选的载荷。

4. **流程控制**：
   - Action 内部可以包含多个步骤，包括调用 API、处理返回数据、最后通过 `commit` 调用一个或多个 mutation 来更新 state。

5. **分发与链式调用**：
   - Action 之间可以相互调用（分发），形成复杂的异步操作流程，而且支持 Promise 的链式调用，便于编写和维护异步逻辑。

**总结：**

- Mutation 关注于同步地改变应用状态，强调的是状态管理的纯函数特性，确保状态变更的可跟踪性。
- Action 则提供了处理异步操作的能力，让 Vuex 能够应对更复杂的业务逻辑，同时保持整体状态管理的清晰和可控。
- 两者相辅相成，共同构成了 Vuex 状态管理的核心机制。

## 3.Redux 和 Vuex 有什么区别，它们的共同思想？

**Redux:**

1. **平台无关性**：Redux 是一个独立的状态管理库，可以与任何 UI 框架（不仅仅是 React）一起使用。
   
2. **不可变数据**：Redux 强制使用不可变数据，每次状态更新都会返回一个新的状态对象，而不是直接修改旧状态。
   
3. **单一数据源**：Redux 应用只有一个单一的 store（状态树），所有状态都集中在这里管理。
   
4. **action 与 reducer**：Redux 中，状态更新通过 action 触发，这些 action 被 reducer 函数处理。reducer 是纯函数，接受旧状态和 action，返回新状态。
   
5. **中间件支持**：Redux 提供强大的中间件系统，允许在 action 到达 reducer 前进行拦截和处理，支持异步操作和日志记录等。
   
6. **开发工具**：Redux DevTools 提供了丰富的调试功能，可以记录每一个状态变化，帮助开发者理解状态流转。

**Vuex:**

1. **Vue 专用**：Vuex 是专门为 Vue.js 框架设计的状态管理库。
   
2. **可变数据**：与 Redux 不同，Vuex 中的状态是可以直接修改的，尽管推荐通过 mutation 来进行。
   
3. **模块化**：Vuex 自带模块化功能，方便大型应用的状态分割管理。
   
4. **mutation 与 action**：Vuex 使用 mutation 来处理同步状态变更，action 则用于处理异步逻辑，但不强制要求所有异步操作都通过 action。
   
5. **状态、getter、mutation、action**：Vuex 定义了明确的角色分工，使状态管理结构清晰。
   
6. **便捷访问**：Vuex 提供了 `mapGetters` 和 `mapActions` 等辅助函数，方便组件访问和触发状态变更。

**共同思想：**

- **单一数据源**：无论是 Redux 还是 Vuex，都提倡应用有一个单一的、集中的状态树，作为整个应用状态的唯一来源。
  
- **状态变更规则**：二者都强调状态变更应该是可预测的，通过明确的规则（Redux 中的 reducer，Vuex 中的 mutation）来执行。
  
- **分离关注点**：通过将状态管理从组件中抽离出来，使得状态逻辑和视图逻辑分离，提高代码的可维护性和可测试性。
  
- **响应式更新**：都支持状态变更后自动更新相关联的视图，确保用户界面与状态保持同步。

**总结：**

总的来说，Redux 和 Vuex 在设计理念上有很多相似之处，都是为了更好地管理应用状态，提升开发效率和应用的可维护性。它们的主要区别在于适用框架、数据处理方式（不可变 vs 可变）、以及一些特性和实现细节。

## 4.Vuex有哪几种属性？

有五种，分别是 State、 Getter、Mutation 、Action、 Module

- state => 基本数据(数据源存放地)
- getters => 从基本数据派生出来的数据
- mutations => 提交更改数据的方法，同步
- actions => 像一个装饰器，包裹mutations，使之可以异步。
- modules => 模块化Vuex

## 5.Vuex和单纯的全局对象有什么区别？

1. **响应式状态管理**：
   - **Vuex** 的状态存储是响应式的，这意味着当 Vue 组件从 store 中读取状态时，如果 store 中的状态发生变化，所有依赖这些状态的组件会自动更新。
   - **单纯全局对象** 不具备这种自动更新视图的能力，你需要手动处理状态变化后的 UI 更新。

2. **状态变更机制**：
   - **Vuex** 强制通过 Mutation 来改变状态，这是一种同步操作，且所有变更都被集中记录，使得状态变更过程清晰可追踪。
   - **单纯全局对象** 中，状态可以在任何地方被随意修改，这不仅难以追踪状态变更的源头，还可能导致难以预料的副作用和 bug。

3. **异步操作处理**：
   - **Vuex** 引入了 Action 来处理异步操作，如 API 调用等。Action 可以触发 Mutation 来间接更新状态，这保持了状态管理的清晰性和可维护性。
   - **单纯全局对象** 本身不提供管理异步逻辑的机制。

4. **开发工具支持**：
   - **Vuex** 与 Vue DevTools 集成，提供了强大的调试功能，可以记录每一次状态变更的细节，帮助开发者快速定位问题。
   - **单纯全局对象** 的状态变更则难以被此类工具跟踪。

5. **模块化和可扩展性**：
   - **Vuex** 支持模块化，允许将庞大的状态树分割成小的、可管理的模块，这对于大型项目至关重要。
   - **单纯全局对象** 没有内置的模块化机制，随着应用复杂度增加，状态管理会变得混乱不堪。

6. **集中管理与解耦**：
   - **Vuex** 通过集中存储和管理应用状态，促进了组件之间的解耦，使得状态逻辑与视图逻辑分离，提高了代码的可读性和可维护性。
   - **单纯全局对象** 直接暴露在各个组件中使用，容易造成组件间的紧耦合。

## 6.为什么 Vuex 的 mutation 中不能做异步操作？

1. **可预测性**：Mutation 必须是同步的，这确保了每次 mutation 的执行都是确定的，没有异步操作带来的不确定性。这样，开发者可以更容易地理解和追踪应用状态的变化，有利于调试和测试。
   
2. **调试友好**：Vuex 的开发工具（Vue DevTools）能够记录并展示每次 mutation 的执行。如果 mutation 中包含异步操作，那么记录和回放这些状态变更会变得非常困难，因为异步操作的完成时间是不可预知的。
   
3. **状态更新的原子性**：Mutation 被视为一个原子操作，它应该一次性完成对状态的修改。如果允许异步操作，那么在状态更新的过程中可能会出现并发问题，导致状态不一致。
   
4. **控制流程**：Vuex 通过 actions 处理异步操作，这样可以保持 mutation 的简洁性，将复杂的业务逻辑和数据获取过程隔离，使得状态变更的控制流程更清晰。
   
5. **避免错误**：异步操作可能在错误处理上带来复杂性，尤其是在多个组件可能同时尝试修改状态的情况下。通过限制 mutation 为同步，可以避免这些潜在的冲突。
   
6. **设计原则**：Vuex 的设计原则之一就是保持状态变更的可预测性和一致性，而异步操作往往违背了这一原则。

# 三、状态管理与存储类

## 1.vuex和localStorage的区别

**Vuex:**

1. **作用**：
   - Vuex 是 Vue.js 应用的状态管理库，集中管理组件之间共享的状态，使得状态的更新和访问变得有序和可追踪。

2. **数据存储**：
   - Vuex 的状态存储在内存中，随着 Vue 应用的运行而存在，关闭或刷新浏览器会丢失。

3. **响应式**：
   - Vuex 的状态是响应式的，当状态改变时，依赖于该状态的组件会自动更新。

4. **变更控制**：
   - 状态变更必须通过提交 mutation 来完成，保证了状态变更的可预测性和可调试性。

5. **生命周期**：
   - Vuex 有其自身的生命周期，包括初始化、更新、模块拆分等，方便管理和组织状态。

6. **辅助工具**：
   - Vuex 提供了如 getter、action、mutation、module 等辅助工具，帮助管理复杂的应用状态。

**localStorage:**

1. **作用**：
   - localStorage 是 HTML5 提供的本地存储 API，用于在用户的浏览器上持久化存储数据，即使关闭浏览器或重启电脑，数据依然存在。

2. **数据类型**：
   - localStorage 只能存储字符串，如果需要存储复杂数据类型（如对象或数组），通常需要使用 JSON.stringify 和 JSON.parse 进行序列化和反序列化。

3. **存储容量**：
   - localStorage 的存储空间通常为 5MB 左右，比内存中的 Vuex 存储空间大。

4. **无状态管理**：
   - localStorage 没有响应式更新，当数据变化时，需要手动处理页面的更新。

5. **跨域限制**：
   - localStorage 遵循同源策略，不同源的页面无法共享数据。

**应用场景：**

- **Vuex** 适合于管理应用运行时的状态，尤其适用于需要实时响应状态变化的场景，以及组件间的复杂交互。
- **localStorage** 更适合于存储用户设置、应用配置等需要长期保留的数据，或者在不同会话之间需要共享数据但不需要实时响应的情况。

**总结：**

Vuex 和 localStorage 各有侧重。Vuex 是为了解决 Vue 应用内部的状态管理问题，提供响应式和控制流；而 localStorage 是浏览器提供的持久化存储解决方案，两者在应用场景和数据管理上有明显的区别。在实际项目中，开发者通常会结合使用，以实现最佳的用户体验和数据管理。
